/*!
* rb-gesture-event 1.1.0
* Â©2025 Nor.E & Null -
* Released under the MIT license
* https://null-nore.github.io/RbGestureEvent/
*/
var t={d:(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{RbEventState:()=>c,RbGestureEvent:()=>u,RbPointerInfo:()=>a});let n=!1;const o=Symbol.for("RBEventList"),i=Symbol.for("RBLongtouch"),r=Symbol.for("RBCallbackMap");class a{move=!1;firstMove=!1;velocity=[0,0];displacement=[0,0];location=[0,0];startLocation=[0,0];velocityTimeOut=setTimeout((()=>{}),1)}class c{time=Date.now();eventType="";scale=1;deltaAngle=0;midPoint=[0,0];midDisplacement=[0,0];maxPoint=0;clickCount=0;lastClickLocation=[0,0];lastClickTime=Date.now();isRotate=!1;firstRotate=!1;isPinch=!1;firstPinch=!1;startLength=0;startAngle=0;startTime=Date.now();pointers=new Map;triggerPointer=new a;pointerCount=0;originEvent=new PointerEvent("none")}const s={press:(t,e,n)=>"down"==t.eventType&&"down"==n,release:(t,e,n)=>"up"==t.eventType&&"up"==n,click:(t,e,n)=>!(!s.release(t,e,n)||0!=t.pointerCount)&&t.clickCount>=1,doubleclick:(t,e,n)=>!!s.click(t,e,n)&&(t.clickCount%2==0&&t.clickCount>0),longtouch:(t,e,n)=>{if("longtouch"==n){const e=Date.now()-t.startTime>=500,n=1==t.maxPoint,o=!t.triggerPointer.move;return e&&n&&o}return!1},dragstart:(t,e,n)=>{if("move"==n||"up"==n){const n=1==t.pointerCount,o=1==e.pointerCount,i=t.triggerPointer.firstMove,r=t.triggerPointer.move;return n&&(i||!o)&&r}return!1},dragmove:(t,e,n)=>{if("move"==n){const e=1==t.pointerCount,n=t.triggerPointer.firstMove,o=t.triggerPointer.move;return e&&o&&!n}return!1},dragend:(t,e,n)=>{if("up"==n||"down"==n){const n=1==e.pointerCount,o=1!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}},dragcancel:(t,e,n)=>{if("cancel"==n||"down"==n){const n=1==e.pointerCount,o=1!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}return!1},dragleft:(t,e,n)=>{if(s.dragmove(t,e,n)){return t.triggerPointer.displacement[0]<0}return!1},dragright:(t,e,n)=>{if(s.dragmove(t,e,n)){return t.triggerPointer.displacement[0]>0}return!1},dragup:(t,e,n)=>{if(s.dragmove(t,e,n)){return t.triggerPointer.displacement[1]<0}return!1},dragdown:(t,e,n)=>{if(s.dragmove(t,e,n)){return t.triggerPointer.displacement[1]>0}return!1},doubledragstart:(t,e,n)=>{if("move"==n||"down"==n){const n=2==t.pointerCount,o=2==e.pointerCount,i=t.triggerPointer.firstMove||e.triggerPointer.firstMove,r=t.triggerPointer.move||e.triggerPointer.move;return n&&(i||!o)&&r}return!1},doubledragmove:(t,e,n)=>{if("move"==n){const n=2==t.pointerCount,o=t.triggerPointer.firstMove||e.triggerPointer.firstMove,i=t.triggerPointer.move||e.triggerPointer.move;return n&&i&&!o}return!1},doubledragend:(t,e,n)=>{if("up"==n||"down"==n){const n=2==e.pointerCount,o=2!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}return!1},doubledragcancel:(t,e,n)=>{if("cancel"==n||"down"==n){const n=2==e.pointerCount,o=2!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}return!1},swipeleft:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=n<-l.config.threshold,a=n<0&&Math.abs(n)>Math.abs(o),c=t.triggerPointer.move,s=t.triggerPointer.velocity[0]<-l.config.swipeVelocityThreshold;return i&&c&&a&&r&&s}return!1},swiperight:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=n>l.config.threshold,a=n>0&&Math.abs(n)>Math.abs(o),c=t.triggerPointer.move,s=t.triggerPointer.velocity[0]>l.config.swipeVelocityThreshold;return i&&c&&a&&r&&s}return!1},swipeup:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=o<-l.config.threshold,a=o<0&&Math.abs(o)>Math.abs(n),c=t.triggerPointer.move,s=t.triggerPointer.velocity[1]<-l.config.swipeVelocityThreshold;return i&&c&&a&&r&&s}return!1},swipedown:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=o>l.config.threshold,a=o>0&&Math.abs(o)>Math.abs(n),c=t.triggerPointer.move,s=t.triggerPointer.velocity[1]>l.config.swipeVelocityThreshold;return i&&c&&a&&r&&s}return!1},pinchstart:(t,e,n)=>{if("move"==n){const e=t.isPinch,n=t.firstPinch;return e&&n}return!1},pinchmove:(t,e,n)=>{if("move"==n){const e=t.isPinch,n=t.firstPinch;return e&&!n}return!1},pinchend:(t,e,n)=>{if("up"==n){const n=e.isPinch,o=!t.isPinch;return n&&o}return!1},pinchcancel:(t,e,n)=>{if("cancel"==n){const n=e.isPinch,o=!t.isPinch;return n&&o}return!1},pinchin:(t,e,n)=>{if(s.pinchmove(t,e,n)){return t.scale<1}return!1},pinchout:(t,e,n)=>{if(s.pinchmove(t,e,n)){return t.scale>1}return!1},rotatestart:(t,e,n)=>{if("move"==n){const e=t.isRotate,n=t.firstRotate;return e&&n}return!1},rotatemove:(t,e,n)=>{if("move"==n){const e=t.isRotate,n=t.firstRotate;return e&&!n}return!1},rotateend:(t,e,n)=>{if("up"==n){const n=e.isRotate,o=!t.isRotate;return n&&o}return!1},rotatecancel:(t,e,n)=>{if("cancel"==n){const n=e.isRotate,o=!t.isRotate;return n&&o}return!1}};class l{static eventState=new c;static lastEventState=new c;static outEventState=new c;static condition={};static config={threshold:5,swipeVelocityThreshold:.3,clickThreshold:500,longtouchThreshold:500,angleThreshold:5,scaleThreshold:.05}}class p{static cloneStateTo(t){const e=l.eventState.originEvent;l.eventState.originEvent=null,l[t]=structuredClone(l.eventState),l[t].originEvent=e,l.eventState.originEvent=e}static copyStateToLast(){this.cloneStateTo("lastEventState"),l.lastEventState.time=Date.now()}static copyState(){this.cloneStateTo("outEventState")}static updateEventState(t,e,n){const o=t.pointerId;e.originEvent=t,e.time=Date.now(),e.eventType=n,e.triggerPointer=e.pointers.get(o)}static initializeTwoPointerState(t){const e=[...t.pointers.values()].slice(0,2).map((t=>[t.location[0],t.location[1]]));t.startLength=p.eDistance(...e),t.startAngle=p.refAngle(...e),t.midPoint=p.midPoint(...e)}static updateTwoPointerState(t){const[e,n]=[...t.pointers.values()].slice(0,2),{location:o,displacement:i}=e,{location:r,displacement:a}=n,c=p.eDistance(o,r),s=p.refAngle(o,r);t.scale=c/t.startLength,t.deltaAngle=s-t.startAngle,t.midPoint=p.midPoint(o,r),t.midDisplacement=p.midPoint(i,a)}static updateVelocity(t,e,n){clearTimeout(t.velocityTimeOut),t.velocityTimeOut=setTimeout((()=>{t.velocity=[0,0]}),100);const o=Date.now()-e.time;t.velocity=[(t.location[0]-e.pointers.get(n).location[0])/o,(t.location[1]-e.pointers.get(n).location[1])/o]}static pointerdown=t=>{p.copyStateToLast();const e=l.eventState;p.updateEventState(t,e,"down");const n=t.pointerId;e.pointers.set(n,{move:!1,firstMove:!1,velocity:[0,0],displacement:[0,0],location:[t.clientX,t.clientY],startLocation:[t.clientX,t.clientY],velocityTimeOut:setTimeout((()=>{}),100)}),e.triggerPointer=e.pointers.get(n),e.pointerCount++,e.maxPoint=Math.max(e.maxPoint,e.pointerCount),1==e.pointerCount&&(e.startTime=Date.now()),2==e.pointerCount&&p.initializeTwoPointerState(e),p.copyState()};static pointermove=t=>{p.copyStateToLast();const e=l.eventState,n=l.lastEventState;if(e.pointerCount<1)return;const o=t.pointerId,i=e.pointers.get(o),r=[t.clientX-i.startLocation[0],t.clientY-i.startLocation[1]];Math.hypot(...r)>l.config.threshold&&(p.updateEventState(t,e,"move"),i.firstMove=!i.move,i.move=!0,i.location=[t.clientX,t.clientY],i.displacement=r,p.updateVelocity(i,n,o),e.pointerCount>=2&&p.updateTwoPointerState(e),e.firstRotate=!e.isRotate,e.isRotate=Math.abs(e.deltaAngle)>=l.config.angleThreshold||e.isRotate,e.firstPinch=!e.isPinch,e.isPinch=Math.abs(1-e.scale)>=l.config.scaleThreshold||e.isPinch,p.copyState())};static pointerup=t=>{p.copyStateToLast();const e=l.eventState;p.updateEventState(t,e,"up"),e.pointers.delete(t.pointerId),e.pointerCount--,1==e.maxPoint&&e.startTime-e.time<500&&!e.triggerPointer.move?(p.eDistance(e.triggerPointer.location,e.lastClickLocation)<20&&Date.now()-e.lastClickTime<500?e.clickCount++:e.clickCount=1,e.lastClickTime=Date.now(),e.lastClickLocation=[...e.triggerPointer.location]):e.clickCount=0,e.pointerCount<2&&(e.isRotate=!1,e.isPinch=!1,e.deltaAngle=0,e.scale=1),0==e.pointerCount&&(e.maxPoint=0),p.copyState()};static pointerCancel=t=>{p.copyStateToLast();const e=l.eventState;p.updateEventState(t,e,"cancel"),e.pointers.delete(t.pointerId),e.pointerCount--,e.pointerCount<2&&(e.isRotate=!1,e.isPinch=!1,e.deltaAngle=0,e.scale=1),0==e.pointerCount&&(e.maxPoint=0),p.copyState()};static dispatchEvent(t,e){for(const n of Object.keys(t[o]))s[n](l.eventState,l.lastEventState,e)&&t[o][n].forEach((t=>t(l.outEventState)))}static downDispatch(){p.dispatchEvent(this,"down"),1==l.eventState.pointerCount?this[i]=setTimeout((()=>{p.longtouchDispatch(this)}),l.config.longtouchThreshold):this[i]&&clearTimeout(this[i])}static longtouchDispatch(t){p.dispatchEvent(t,"longtouch")}static moveDispatch(){l.eventState.pointerCount>=1&&p.dispatchEvent(this,"move")}static upDispatch(){p.dispatchEvent(this,"up"),clearTimeout(this[i])}static outDispatch(){clearTimeout(this[i])}static cancelDispatch(){p.dispatchEvent(this,"cancel"),clearTimeout(this[i])}static eDistance=([t,e],[n,o])=>{const[i,r]=[t-n,e-o];return Math.hypot(i,r)};static refAngle=([t,e],[n,o])=>{const[i,r]=[t-n,e-o];return Math.atan2(r,i)/Math.PI*180};static midPoint=([t,e],[n,o])=>[(t+n)/2,(e+o)/2]}class u{static _initialize(){const t=()=>{[["pointerdown",p.pointerdown],["pointermove",p.pointermove],["pointerup",p.pointerup],["pointercancel",p.pointerCancel]].forEach((t=>window.addEventListener(t[0],t[1],!0)))};"interactive"!=document.readyState?document.addEventListener("DOMContentLoaded",t):t()}static setDebug(t){n=t,n&&console.log("%cRbGestureEvent - debug mode on, version: 1.1.1","\n            color: white;\n            background-color: #333333; \n            font-weight: bold;\n            text-shadow: 0 0 5px white;\n            padding: 0.5em;\n            border-left: 5px solid #ff0000;\n            border-right: 5px solid #ff0000;\n            ")}static setConfig(t){Object.assign(l.config,t)}static registerEventListener(t,e,i){if(null==s[e])throw new Error(`event type ${e} not found`);let a;if(t[o]||(t[o]={},t.addEventListener("pointerdown",p.downDispatch),t.addEventListener("pointermove",p.moveDispatch),t.addEventListener("pointerup",p.upDispatch),t.addEventListener("pointerout",p.outDispatch),t.addEventListener("pointercancel",p.cancelDispatch)),t[o][e]||(t[o][e]=[]),""!=i.name)if(t[r]){if(t[r].has(i)){n&&console.warn("callback already registered\n",i);const e=t[r].get(i);a=e.boundcallback,e.count+=1}}else t[r]=new WeakMap,a=i.bind(t),t[r].set(i,{boundcallback:a,count:1});else a=i.bind(t);t[o][e].push(a),n&&(console.log(`register event: ${e} on`,t),console.log("eventList:",t[o]))}static cancelEventListener(t,e,i){if(n&&console.log(`cancel event: ${e} on`,t),!t[r].has(i))throw n&&console.error("callback not found\n","eventList:",t[o],"\n","callback:",i),new Error("callback not found");{const a=t[o][e];let{boundcallback:c,count:s}=t[r].get(i);const l=a.indexOf(c);a.splice(l,1),s-=1,0==s&&t[r].delete(i),0==t[o][e].length&&(delete t[o][e],0==Object.keys(t[o]).length&&(delete t[o],t.removeEventListener("pointerdown",p.downDispatch),t.removeEventListener("pointermove",p.moveDispatch),t.removeEventListener("pointerup",p.upDispatch),t.removeEventListener("pointerout",p.outDispatch),t.removeEventListener("pointercancel",p.cancelDispatch))),n&&console.log("eventList:",t[o])}}static setCondition(t,e){s[t]&&n&&console.warn(`event type ${t} already exists, will be overwritten`),s[t]=e}static removeCondition(t){if(!s[t])throw new Error(`event type ${t} not found`);delete s[t]}}u._initialize();